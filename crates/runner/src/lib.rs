use std::{
    collections::HashMap,
    sync::{Arc, RwLock},
};

use anyhow::{Result, bail};
use kcl_ast::{
    MAIN_PKG,
    ast::{Module, Program},
};
use kcl_parser::{KCLModuleCache, ParseSessionRef, load_program};
use kcl_query::apply_overrides;
use kcl_sema::resolver::{
    Options, resolve_program, resolve_program_with_opts, scope::ProgramScope,
};
pub use runner::{ExecProgramArgs, ExecProgramResult, MapErrorResult};
use runner::{FastRunner, RunnerOptions};

pub mod runner;

#[cfg(test)]
pub mod tests;

/// After the kcl program passed through kcl-parser in the compiler frontend,
/// KCL needs to resolve ast, generate corresponding LLVM IR, dynamic link library or
/// executable file for kcl program in the compiler backend.
///
/// Method “execute” is the entry point for the compiler backend.
///
/// It returns the KCL program executing result as Result<a_json_string, an_err_string>,
/// and mainly takes "program" (ast.Program returned by kcl-parser) as input.
///
/// "args" is the items selected by the user in the KCL CLI.
///
/// This method will first resolve “program” (ast.Program) and save the result to the "scope" (ProgramScope).
///
/// Then, dynamic link libraries is generated by KclAssembler, and method "KclAssembler::gen_libs"
/// will return dynamic link library paths in a "Vec<String>";
///
/// KclAssembler is mainly responsible for concurrent compilation of multiple files.
/// Single-file compilation in each thread in concurrent compilation is the responsibility of KclLibAssembler.
/// In the future, it may support the dynamic link library generation of multiple intermediate language.
/// KclLibAssembler currently only supports LLVM IR.
///
/// After linking all dynamic link libraries by KclLinker, method "KclLinker::link_all_libs" will return a path
/// for dynamic link library after linking.
///
/// At last, KclLibRunner will be constructed and call method "run" to execute the kcl program.
///
/// **Note that it is not thread safe.**
///
/// # Examples
///
/// ```
/// use kcl_runner::{exec_program, ExecProgramArgs};
/// use kcl_parser::ParseSession;
/// use std::sync::Arc;
///
/// // Create sessions
/// let sess = Arc::new(ParseSession::default());
/// // Get default args
/// let mut args = ExecProgramArgs::default();
/// args.k_filename_list = vec!["./src/test_datas/init_check_order_0/main.k".to_string()];
///
/// // Resolve ast, generate libs, link libs and execute.
/// // Result is the kcl in json format.
/// let result = exec_program(sess, &args).unwrap();
/// ```
pub fn exec_program(sess: ParseSessionRef, args: &ExecProgramArgs) -> Result<ExecProgramResult> {
    // parse args from json string
    let opts = args.get_load_program_options();
    let kcl_paths_str = args
        .k_filename_list
        .iter()
        .map(|s| s.as_str())
        .collect::<Vec<&str>>();
    let module_cache = KCLModuleCache::default();
    let mut program = load_program(
        sess.clone(),
        kcl_paths_str.as_slice(),
        Some(opts),
        Some(module_cache),
    )?
    .program;
    apply_overrides(
        &mut program,
        &args.overrides,
        &[],
        args.print_override_ast || args.debug > 0,
    )?;
    execute(sess, program, args)
}

/// After the kcl program passed through kcl-parser in the compiler frontend,
/// KCL needs to resolve ast, generate corresponding LLVM IR, dynamic link library or
/// executable file for kcl program in the compiler backend.
///
/// Method “execute” is the entry point for the compiler backend.
///
/// It returns the KCL program executing result as Result<a_json_string, an_err_string>,
/// and mainly takes "program" (ast.Program returned by kcl-parser) as input.
///
/// "args" is the items selected by the user in the KCL CLI.
///
/// This method will first resolve “program” (ast.Program) and save the result to the "scope" (ProgramScope).
///
/// Then, dynamic link libraries is generated by KclAssembler, and method "KclAssembler::gen_libs"
/// will return dynamic link library paths in a "Vec<String>";
///
/// KclAssembler is mainly responsible for concurrent compilation of multiple files.
/// Single-file compilation in each thread in concurrent compilation is the responsibility of KclLibAssembler.
/// In the future, it may support the dynamic link library generation of multiple intermediate language.
/// KclLibAssembler currently only supports LLVM IR.
///
/// After linking all dynamic link libraries by KclLinker, method "KclLinker::link_all_libs" will return a path
/// for dynamic link library after linking.
///
/// At last, KclLibRunner will be constructed and call method "run" to execute the kcl program.
///
/// **Note that it is not thread safe.**
///
/// # Examples
///
/// ```
/// use kcl_runner::{execute, runner::ExecProgramArgs};
/// use kcl_parser::{load_program, ParseSession};
/// use kcl_ast::ast::Program;
/// use std::sync::Arc;
///
/// // Create sessions
/// let sess = Arc::new(ParseSession::default());
/// // Get default args
/// let args = ExecProgramArgs::default();
/// let opts = args.get_load_program_options();
///
/// // Parse kcl file
/// let kcl_path = "./src/test_datas/init_check_order_0/main.k";
/// let prog = load_program(sess.clone(), &[kcl_path], Some(opts), None).unwrap().program;
///     
/// // Resolve ast, generate libs, link libs and execute.
/// // Result is the kcl in json format.
/// let result = execute(sess, prog, &args).unwrap();
/// ```
pub fn execute(
    sess: ParseSessionRef,
    mut program: Program,
    args: &ExecProgramArgs,
) -> Result<ExecProgramResult> {
    // If the user only wants to compile the kcl program, the following code will only resolve ast.
    if args.compile_only {
        let mut resolve_opts = Options::default();
        resolve_opts.merge_program = false;
        // Resolve ast
        let scope = resolve_program_with_opts(&mut program, resolve_opts, None);
        emit_compile_diag_to_string(sess, &scope, args.compile_only)?;
        return Ok(ExecProgramResult::default());
    }
    // Resolve ast
    let scope = resolve_program(&mut program);
    // Emit parse and resolve errors if exists.
    emit_compile_diag_to_string(sess, &scope, false)?;
    Ok(FastRunner::new(Some(RunnerOptions {
        plugin_agent_ptr: args.plugin_agent,
    }))
    .run(&program, args)?)
}

/// `execute_module` can directly execute the ast `Module`.
/// `execute_module` constructs `Program` with default pkg name `MAIN_PKG`,
/// and calls method `execute` with default `plugin_agent` and `ExecProgramArgs`.
/// For more information, see doc above method `execute`.
///
/// **Note that it is not thread safe.**
pub fn execute_module(m: Module) -> Result<ExecProgramResult> {
    let mut pkgs = HashMap::new();
    let mut modules = HashMap::new();
    pkgs.insert(MAIN_PKG.to_string(), vec![m.filename.clone()]);
    modules.insert(m.filename.clone(), Arc::new(RwLock::new(m)));

    let prog = Program {
        root: MAIN_PKG.to_string(),
        pkgs,
        modules,
        pkgs_not_imported: HashMap::new(),
        modules_not_imported: HashMap::new(),
    };

    execute(
        ParseSessionRef::default(),
        prog,
        &ExecProgramArgs::default(),
    )
}

// [`emit_compile_diag_to_string`] will emit compile diagnostics to string, including parsing and resolving diagnostics.
fn emit_compile_diag_to_string(
    sess: ParseSessionRef,
    scope: &ProgramScope,
    include_warnings: bool,
) -> Result<()> {
    let mut res_str = sess.1.write().emit_to_string()?;
    let sema_err = scope.emit_diagnostics_to_string(sess.0.clone(), include_warnings);
    if let Err(err) = &sema_err {
        #[cfg(not(target_os = "windows"))]
        res_str.push('\n');
        #[cfg(target_os = "windows")]
        res_str.push_str("\r\n");
        res_str.push_str(err);
    }

    res_str
        .is_empty()
        .then(|| Ok(()))
        .unwrap_or_else(|| bail!(res_str))
}
